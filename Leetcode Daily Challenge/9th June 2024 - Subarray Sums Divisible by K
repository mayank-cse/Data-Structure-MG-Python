### Problem Description

ğŸ” **Problem:** Given an integer array `nums` and an integer `k`, return the number of non-empty subarrays that have a sum divisible by `k`.

A subarray is a contiguous part of an array.

### Example

1. **Input:** `nums = [4,5,0,-2,-3,1]`, `k = 5`
   **Output:** `7`
   **Explanation:** There are 7 subarrays with a sum divisible by `k = 5`:
   - `[4, 5, 0, -2, -3, 1]`
   - `[5]`
   - `[5, 0]`
   - `[5, 0, -2, -3]`
   - `[0]`
   - `[0, -2, -3]`
   - `[-2, -3]`

2. **Input:** `nums = [5]`, `k = 9`
   **Output:** `0`

### Solution Explanation

To solve this problem, we need to efficiently count subarrays whose sums are divisible by `k`. We can utilize the prefix sum approach with a hash map to track remainders when the prefix sum is divided by `k`. Here's the step-by-step approach:

1. **Initialization:**
   - Use a hash map (`prefixSum`) to store remainders of prefix sums and their frequencies.
   - Initialize `currSum` to 0.
   - Store `prefixSum[0] = 1` to handle cases where the subarray itself is divisible by `k`.

2. **Iterate Through Array:**
   - For each element, update the `currSum`.
   - Compute the remainder (`currSum % k`).
   - If this remainder has been seen before, it means we have found subarrays whose sums are divisible by `k`, so increase the count.
   - Update the frequency of the remainder in the hash map.

### Code Implementation

Here is the solution in Python, Java, and C++ with emojis in the explanation:

#### Python

```python
def subarraysDivByK(nums, k):
    prefixSum = {0: 1}  # ğŸ—ƒï¸ Initialize the hash map with base case
    currSum = 0  # â• Initialize current sum
    count = 0  # ğŸ”¢ Initialize count of subarrays

    for num in nums:  # ğŸ”„ Iterate through array
        currSum += num  # â• Add current element to current sum
        remainder = currSum % k  # â— Compute remainder

        if remainder in prefixSum:  # ğŸ” Check if remainder is already in the map
            count += prefixSum[remainder]  # ğŸ“ˆ Increase count by frequency of remainder

        prefixSum[remainder] = prefixSum.get(remainder, 0) + 1  # ğŸ“ Update frequency of remainder

    return count  # âœ”ï¸ Return count of subarrays
```

#### Java

```java
public class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        Map<Integer, Integer> prefixSum = new HashMap<>();  // ğŸ—ƒï¸ Initialize the hash map
        prefixSum.put(0, 1);  // ğŸ“ Store base case
        int currSum = 0;  // â• Initialize current sum
        int count = 0;  // ğŸ”¢ Initialize count of subarrays

        for (int num : nums) {  // ğŸ”„ Iterate through array
            currSum += num;  // â• Add current element to current sum
            int remainder = currSum % k;  // â— Compute remainder

            if (prefixSum.containsKey(remainder)) {  // ğŸ” Check if remainder is already in the map
                count += prefixSum.get(remainder);  // ğŸ“ˆ Increase count by frequency of remainder
            }

            prefixSum.put(remainder, prefixSum.getOrDefault(remainder, 0) + 1);  // ğŸ“ Update frequency of remainder
        }

        return count;  // âœ”ï¸ Return count of subarrays
    }
}
```

#### C++

```cpp
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        unordered_map<int, int> prefixSum;  // ğŸ—ƒï¸ Initialize the hash map
        prefixSum[0] = 1;  // ğŸ“ Store base case
        int currSum = 0;  // â• Initialize current sum
        int count = 0;  // ğŸ”¢ Initialize count of subarrays

        for (int num : nums) {  // ğŸ”„ Iterate through array
            currSum += num;  // â• Add current element to current sum
            int remainder = currSum % k;  // â— Compute remainder

            if (prefixSum.find(remainder) != prefixSum.end()) {  // ğŸ” Check if remainder is already in the map
                count += prefixSum[remainder];  // ğŸ“ˆ Increase count by frequency of remainder
            }

            prefixSum[remainder]++;  // ğŸ“ Update frequency of remainder
        }

        return count;  // âœ”ï¸ Return count of subarrays
    }
};
```

### Explanation

1. **Initialize Structures:** ğŸ—ƒï¸ Use a hash map to store the remainders and their frequencies. ğŸ“ Store a base case to handle subarrays starting from the beginning.

2. **Iterate and Update:** ğŸ”„ Iterate through the array, adding each element to the current sum. â— Compute the remainder when dividing the current sum by `k`.

3. **Check Conditions:** ğŸ” If the remainder is found in the map, increase the count by the frequency of the remainder. ğŸ“ˆ Update the frequency of the remainder in the map.

By using this approach, we efficiently count the number of subarrays with sums that are divisible by `k`, ensuring a linear time complexity.
